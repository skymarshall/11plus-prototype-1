-- =====================================================
-- UK 11+ Questions & Answers - Supabase (PostgreSQL) Schema
-- =====================================================
-- Single script: core content, user profiles, practice sessions, and progress.
-- Run in the Supabase SQL Editor to create all tables and RLS.
--
-- Usage: Paste into Supabase Dashboard → SQL Editor → Run
-- =====================================================

-- Custom types for question_type and answer_type
CREATE TYPE question_type_enum AS ENUM (
  'multiple_choice', 'free_text'
);

CREATE TYPE answer_type_enum AS ENUM (
  'option_id', 'text'
);

-- =====================================================
-- Core Tables
-- =====================================================

-- 1. Subjects table
CREATE TABLE subjects (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    code VARCHAR(20) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_subjects_name ON subjects(name);
CREATE INDEX idx_subjects_code ON subjects(code);

-- 2. Topics table (hierarchical: parent_topic_id NULL = root, else child of another topic)
CREATE TABLE topics (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    subject_id INT NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
    parent_topic_id INT REFERENCES topics(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(subject_id, parent_topic_id, name)
);

CREATE INDEX idx_topics_subject ON topics(subject_id);
CREATE INDEX idx_topics_parent ON topics(parent_topic_id);

-- 3. Questions table (difficulty is implied by topic hierarchy)
CREATE TABLE questions (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    subject_id INT NOT NULL REFERENCES subjects(id) ON DELETE RESTRICT,
    topic_id INT REFERENCES topics(id) ON DELETE SET NULL,
    question_type question_type_enum NOT NULL DEFAULT 'multiple_choice',
    question_text TEXT NOT NULL,
    question_image_url VARCHAR(500),
    explanation TEXT,
    points INT DEFAULT 1,
    time_limit_seconds INT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    is_active BOOLEAN DEFAULT true
);

CREATE INDEX idx_questions_subject ON questions(subject_id);
CREATE INDEX idx_questions_topic ON questions(topic_id);
CREATE INDEX idx_questions_active ON questions(is_active);
CREATE INDEX idx_questions_type ON questions(question_type);

-- Trigger to auto-update updated_at
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER subjects_updated_at
    BEFORE UPDATE ON subjects
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

CREATE TRIGGER topics_updated_at
    BEFORE UPDATE ON topics
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

CREATE TRIGGER questions_updated_at
    BEFORE UPDATE ON questions
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

-- 4. Answer Options table (no option_letter; options shown in random order per attempt; order recorded in user_question_attempt_option_order)
CREATE TABLE answer_options (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    option_text TEXT NOT NULL,
    option_image_url VARCHAR(500),
    is_correct BOOLEAN DEFAULT false,
    display_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_answer_options_question ON answer_options(question_id);
CREATE INDEX idx_answer_options_correct ON answer_options(is_correct);

-- 5. Correct Answers table
CREATE TABLE correct_answers (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    answer_type answer_type_enum NOT NULL,
    answer_value TEXT NOT NULL,
    is_primary BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_correct_answers_question ON correct_answers(question_id);
CREATE INDEX idx_correct_answers_type ON correct_answers(answer_type);

-- =====================================================
-- Supporting Tables
-- =====================================================

-- 6. Question Tags
CREATE TABLE question_tags (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_question_tags_name ON question_tags(name);

CREATE TABLE question_tag_assignments (
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    tag_id INT NOT NULL REFERENCES question_tags(id) ON DELETE CASCADE,
    PRIMARY KEY (question_id, tag_id)
);

CREATE INDEX idx_question_tag_assignments_tag ON question_tag_assignments(tag_id);

-- 7. Question Sets
CREATE TABLE question_sets (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    subject_id INT REFERENCES subjects(id) ON DELETE SET NULL,
    total_questions INT DEFAULT 0,
    total_time_minutes INT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_question_sets_subject ON question_sets(subject_id);

CREATE TRIGGER question_sets_updated_at
    BEFORE UPDATE ON question_sets
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

CREATE TABLE question_set_items (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_set_id INT NOT NULL REFERENCES question_sets(id) ON DELETE CASCADE,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    display_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(question_set_id, question_id)
);

CREATE INDEX idx_question_set_items_set ON question_set_items(question_set_id);
CREATE INDEX idx_question_set_items_order ON question_set_items(question_set_id, display_order);
CREATE INDEX idx_question_set_items_question ON question_set_items(question_id);

-- 8. Question Statistics
CREATE TABLE question_statistics (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL UNIQUE REFERENCES questions(id) ON DELETE CASCADE,
    times_attempted INT DEFAULT 0,
    times_correct INT DEFAULT 0,
    times_incorrect INT DEFAULT 0,
    average_time_seconds DECIMAL(10,2),
    last_attempted_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TRIGGER question_statistics_updated_at
    BEFORE UPDATE ON question_statistics
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

-- =====================================================
-- User & Session Tables
-- =====================================================

-- 9. Profiles (extends Supabase Auth)
-- Supabase Auth provides auth.users. We store app-specific profile data here.
-- A trigger auto-creates a profile when a user signs up (see below).

CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name VARCHAR(100),
    avatar_url VARCHAR(500),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_profiles_display_name ON profiles(display_name);

CREATE TRIGGER profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

-- 10. Practice sessions (optional grouping of attempts)
-- One row per "practice run" (e.g. a set or a custom selection of questions).

CREATE TABLE practice_sessions (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(id) ON DELETE SET NULL,
    question_set_id INT REFERENCES question_sets(id) ON DELETE SET NULL,
    name VARCHAR(200),
    started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_practice_sessions_user ON practice_sessions(user_id);
CREATE INDEX idx_practice_sessions_started ON practice_sessions(started_at);
CREATE INDEX idx_practice_sessions_subject ON practice_sessions(subject_id);
CREATE INDEX idx_practice_sessions_question_set ON practice_sessions(question_set_id);

CREATE TRIGGER practice_sessions_updated_at
    BEFORE UPDATE ON practice_sessions
    FOR EACH ROW EXECUTE PROCEDURE update_updated_at();

-- 11. User question attempts (progress per question)
-- One row per user per attempt at a question. Links to optional practice_session.

CREATE TABLE user_question_attempts (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    practice_session_id INT REFERENCES practice_sessions(id) ON DELETE SET NULL,
    -- For multiple choice: store the chosen option (display order is in user_question_attempt_option_order)
    answer_option_id INT REFERENCES answer_options(id) ON DELETE SET NULL,
    -- For free text: store raw value
    answer_value TEXT,
    is_correct BOOLEAN NOT NULL,
    time_taken_seconds INT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_user_question_attempts_user ON user_question_attempts(user_id);
CREATE INDEX idx_user_question_attempts_question ON user_question_attempts(question_id);
CREATE INDEX idx_user_question_attempts_user_question ON user_question_attempts(user_id, question_id);
CREATE INDEX idx_user_question_attempts_session ON user_question_attempts(practice_session_id);
CREATE INDEX idx_user_question_attempts_created ON user_question_attempts(created_at);

-- 12. Option display order per attempt (for multiple choice)
-- Records the order in which answer options were shown to the user for each attempt.
-- display_position 1 = first option shown, 2 = second, etc. Populate when showing the question.

CREATE TABLE user_question_attempt_option_order (
    user_question_attempt_id INT NOT NULL REFERENCES user_question_attempts(id) ON DELETE CASCADE,
    display_position INT NOT NULL,
    answer_option_id INT NOT NULL REFERENCES answer_options(id) ON DELETE CASCADE,
    PRIMARY KEY (user_question_attempt_id, display_position),
    UNIQUE (user_question_attempt_id, answer_option_id)
);

CREATE INDEX idx_attempt_option_order_attempt ON user_question_attempt_option_order(user_question_attempt_id);
CREATE INDEX idx_attempt_option_order_option ON user_question_attempt_option_order(answer_option_id);

-- =====================================================
-- Row Level Security (RLS)
-- =====================================================
-- Users can only read/update their own profile and their own progress.

ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE practice_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_question_attempts ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_question_attempt_option_order ENABLE ROW LEVEL SECURITY;

-- Profiles: users can read and update their own row
CREATE POLICY profiles_select_own ON profiles
    FOR SELECT USING (auth.uid() = id);
CREATE POLICY profiles_update_own ON profiles
    FOR UPDATE USING (auth.uid() = id);
CREATE POLICY profiles_insert_own ON profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- Practice sessions: own rows only
CREATE POLICY practice_sessions_select_own ON practice_sessions
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY practice_sessions_insert_own ON practice_sessions
    FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY practice_sessions_update_own ON practice_sessions
    FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY practice_sessions_delete_own ON practice_sessions
    FOR DELETE USING (auth.uid() = user_id);

-- User question attempts: own rows only
CREATE POLICY user_question_attempts_select_own ON user_question_attempts
    FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY user_question_attempts_insert_own ON user_question_attempts
    FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY user_question_attempts_update_own ON user_question_attempts
    FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY user_question_attempts_delete_own ON user_question_attempts
    FOR DELETE USING (auth.uid() = user_id);

-- Option order: only rows where the attempt belongs to the user
CREATE POLICY attempt_option_order_select_own ON user_question_attempt_option_order
    FOR SELECT USING (
        EXISTS (SELECT 1 FROM user_question_attempts uqa WHERE uqa.id = user_question_attempt_option_order.user_question_attempt_id AND uqa.user_id = auth.uid())
    );
CREATE POLICY attempt_option_order_insert_own ON user_question_attempt_option_order
    FOR INSERT WITH CHECK (
        EXISTS (SELECT 1 FROM user_question_attempts uqa WHERE uqa.id = user_question_attempt_option_order.user_question_attempt_id AND uqa.user_id = auth.uid())
    );
CREATE POLICY attempt_option_order_update_own ON user_question_attempt_option_order
    FOR UPDATE USING (
        EXISTS (SELECT 1 FROM user_question_attempts uqa WHERE uqa.id = user_question_attempt_option_order.user_question_attempt_id AND uqa.user_id = auth.uid())
    );
CREATE POLICY attempt_option_order_delete_own ON user_question_attempt_option_order
    FOR DELETE USING (
        EXISTS (SELECT 1 FROM user_question_attempts uqa WHERE uqa.id = user_question_attempt_option_order.user_question_attempt_id AND uqa.user_id = auth.uid())
    );

-- =====================================================
-- Auto-create profile on signup (Supabase Auth hook)
-- =====================================================
-- When a new user signs up via Supabase Auth, create a matching profiles row.

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, display_name)
    VALUES (
        NEW.id,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1))
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger on auth.users (Supabase stores users in auth schema)
CREATE OR REPLACE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- =====================================================
-- Summary view: progress by topic/subject
-- =====================================================

CREATE OR REPLACE VIEW user_progress_by_topic AS
SELECT
    uqa.user_id,
    t.id AS topic_id,
    t.name AS topic_name,
    t.subject_id,
    s.code AS subject_code,
    s.name AS subject_name,
    COUNT(*) AS attempts,
    COUNT(*) FILTER (WHERE uqa.is_correct) AS correct,
    ROUND(100.0 * COUNT(*) FILTER (WHERE uqa.is_correct) / NULLIF(COUNT(*), 0), 1) AS pct_correct
FROM user_question_attempts uqa
JOIN questions q ON q.id = uqa.question_id
JOIN topics t ON t.id = q.topic_id
JOIN subjects s ON s.id = t.subject_id
GROUP BY uqa.user_id, t.id, t.name, t.subject_id, s.code, s.name;

-- =====================================================
-- Verification (run separately if needed)
-- =====================================================
-- SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND (tablename LIKE '%question%' OR tablename IN ('subjects','topics','profiles','practice_sessions','user_question_attempts','user_question_attempt_option_order'));
