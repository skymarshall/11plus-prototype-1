# UK 11+ Questions & Answers - Supabase (PostgreSQL) Data Model Design

## Overview

This document describes the **Supabase (PostgreSQL)** data model for the UK 11+ practice platform. All schema is defined in a single SQL script run in the Supabase SQL Editor:

- **`create_11plus_supabase.sql`** – Types, core content (subjects, topics, questions, answers, tags, sets, statistics), user profiles, practice sessions, attempt history, option display order, RLS, auth trigger, and progress view.

The 11+ exam typically covers:
- Mathematics
- English
- Verbal Reasoning
- Non-Verbal Reasoning

## Requirements

- Store questions with multiple choice options
- Support question types: multiple choice and free text only
- Track subjects and a structured hierarchy of topics (difficulty is reflected by topic placement)
- Store correct answers
- Support explanations/hints
- Support images/diagrams for questions and for answer options (see Image support below)
- Track metadata (creation date, usage, etc.)
- **User accounts**: link to Supabase Auth and store profile data
- **Practice sessions**: one row per test run (user, subject/set, started/completed)
- **Progress**: record each user’s attempt per question (answer chosen, correct/incorrect, time)
- **Security**: Row Level Security (RLS) so users only access their own data

---

## Custom Types (PostgreSQL ENUMs)

Defined in `create_11plus_supabase.sql` before the tables:

```sql
CREATE TYPE question_type_enum AS ENUM (
  'multiple_choice', 'free_text'
);

CREATE TYPE answer_type_enum AS ENUM (
  'option_id', 'text'
);
```

---

## Entity Relationship Design

### Core Tables

#### 1. `subjects`

Stores the main subject categories (Mathematics, English, Verbal Reasoning, Non-Verbal Reasoning).

```sql
CREATE TABLE subjects (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    code VARCHAR(20) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_subjects_name ON subjects(name);
CREATE INDEX idx_subjects_code ON subjects(code);
```

- `updated_at` is maintained by a trigger calling `update_updated_at()`.

#### 2. `topics`

Stores a **hierarchical** set of topics within each subject (e.g. Mathematics → Number → Fractions → Adding fractions). The hierarchy is formed by `parent_topic_id`: `NULL` means a root-level topic; a non-NULL value references another topic in the same subject. Difficulty can be represented by topic placement (e.g. “Fractions – introductory” vs “Fractions – advanced”) or by separate child topics.

```sql
CREATE TABLE topics (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    subject_id INT NOT NULL REFERENCES subjects(id) ON DELETE CASCADE,
    parent_topic_id INT REFERENCES topics(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(subject_id, parent_topic_id, name)
);

CREATE INDEX idx_topics_subject ON topics(subject_id);
CREATE INDEX idx_topics_parent ON topics(parent_topic_id);
```

#### 3. `questions`

Main table for storing questions. Uses the custom ENUM for `question_type` (multiple choice or free text). Difficulty is not stored on questions; it is implied by the topic hierarchy (e.g. introductory vs advanced topics).

```sql
CREATE TABLE questions (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    subject_id INT NOT NULL REFERENCES subjects(id) ON DELETE RESTRICT,
    topic_id INT REFERENCES topics(id) ON DELETE SET NULL,
    question_type question_type_enum NOT NULL DEFAULT 'multiple_choice',
    question_text TEXT NOT NULL,
    question_image_url VARCHAR(500),
    explanation TEXT,
    points INT DEFAULT 1,
    time_limit_seconds INT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    is_active BOOLEAN DEFAULT true
);

CREATE INDEX idx_questions_subject ON questions(subject_id);
CREATE INDEX idx_questions_topic ON questions(topic_id);
CREATE INDEX idx_questions_active ON questions(is_active);
CREATE INDEX idx_questions_type ON questions(question_type);
```

#### 4. `answer_options`

Stores multiple choice options for questions. Options are identified by `id` only; there is no `option_letter`, because the app shows options in a **random order** to the user each time. The order in which a specific user saw the options for a given attempt is recorded in `user_question_attempt_option_order` (see §12). `display_order` is the author’s default order (e.g. for editing); it does not dictate the order shown to the user.

```sql
CREATE TABLE answer_options (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    option_text TEXT NOT NULL,
    option_image_url VARCHAR(500),
    is_correct BOOLEAN DEFAULT false,
    display_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_answer_options_question ON answer_options(question_id);
CREATE INDEX idx_answer_options_correct ON answer_options(is_correct);
```

#### 5. `correct_answers`

Stores correct answers (supports multiple correct answers where needed). Uses `answer_type_enum`: `option_id` for multiple choice (value is the chosen option’s id), `text` for free text.

```sql
CREATE TABLE correct_answers (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    answer_type answer_type_enum NOT NULL,
    answer_value TEXT NOT NULL,
    is_primary BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_correct_answers_question ON correct_answers(question_id);
CREATE INDEX idx_correct_answers_type ON correct_answers(answer_type);
```

---

### Supporting Tables

#### 6. `question_tags` and `question_tag_assignments`

Flexible categorization and searchability.

```sql
CREATE TABLE question_tags (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_question_tags_name ON question_tags(name);

CREATE TABLE question_tag_assignments (
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    tag_id INT NOT NULL REFERENCES question_tags(id) ON DELETE CASCADE,
    PRIMARY KEY (question_id, tag_id)
);

CREATE INDEX idx_question_tag_assignments_tag ON question_tag_assignments(tag_id);
```

#### 7. `question_sets` and `question_set_items`

Grouping questions into practice papers or exams.

```sql
CREATE TABLE question_sets (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    subject_id INT REFERENCES subjects(id) ON DELETE SET NULL,
    total_questions INT DEFAULT 0,
    total_time_minutes INT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_question_sets_subject ON question_sets(subject_id);

CREATE TABLE question_set_items (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_set_id INT NOT NULL REFERENCES question_sets(id) ON DELETE CASCADE,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    display_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(question_set_id, question_id)
);

CREATE INDEX idx_question_set_items_set ON question_set_items(question_set_id);
CREATE INDEX idx_question_set_items_order ON question_set_items(question_set_id, display_order);
CREATE INDEX idx_question_set_items_question ON question_set_items(question_id);
```

#### 8. `question_statistics`

Aggregate question performance and usage (times attempted, correct/incorrect, average time).

```sql
CREATE TABLE question_statistics (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id INT NOT NULL UNIQUE REFERENCES questions(id) ON DELETE CASCADE,
    times_attempted INT DEFAULT 0,
    times_correct INT DEFAULT 0,
    times_incorrect INT DEFAULT 0,
    average_time_seconds DECIMAL(10,2),
    last_attempted_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ DEFAULT now()
);
```

---

### User & Session Tables

Defined in **`create_11plus_supabase.sql`** (after core and supporting tables). These tables extend Supabase Auth and track practice sessions and per-question attempts. RLS ensures users only see their own rows.

#### 9. `profiles`

Extends `auth.users` with app-specific profile data. One row per user; `id` is the auth user UUID.

```sql
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name VARCHAR(100),
    avatar_url VARCHAR(500),
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_profiles_display_name ON profiles(display_name);
```

- **Trigger**: `on_auth_user_created` on `auth.users` calls `handle_new_user()` to insert a row into `profiles` on signup (using `raw_user_meta_data` or email for `display_name`).
- **RLS**: Users can SELECT, UPDATE, INSERT only their own row (`auth.uid() = id`).

#### 10. `practice_sessions`

One row per practice/test run. Links user to subject (and optionally a predefined question set).

```sql
CREATE TABLE practice_sessions (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(id) ON DELETE SET NULL,
    question_set_id INT REFERENCES question_sets(id) ON DELETE SET NULL,
    name VARCHAR(200),
    started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_practice_sessions_user ON practice_sessions(user_id);
CREATE INDEX idx_practice_sessions_started ON practice_sessions(started_at);
CREATE INDEX idx_practice_sessions_subject ON practice_sessions(subject_id);
CREATE INDEX idx_practice_sessions_question_set ON practice_sessions(question_set_id);
```

- **user_id**: Who took the test.
- **subject_id**: Which of the four areas; used for “random 10 questions” tests and “My sessions” display.
- **question_set_id**: Optional; used when the test is from a fixed set.
- **started_at** / **completed_at**: Session timing; set `completed_at` when the user finishes.
- **RLS**: Users can SELECT, INSERT, UPDATE, DELETE only their own rows (`auth.uid() = user_id`).

#### 11. `user_question_attempts`

One row per user attempt at a single question. Optional link to `practice_sessions` to group attempts per test.

```sql
CREATE TABLE user_question_attempts (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    question_id INT NOT NULL REFERENCES questions(id) ON DELETE CASCADE,
    practice_session_id INT REFERENCES practice_sessions(id) ON DELETE SET NULL,
    answer_option_id INT REFERENCES answer_options(id) ON DELETE SET NULL,
    answer_value TEXT,
    is_correct BOOLEAN NOT NULL,
    time_taken_seconds INT,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX idx_user_question_attempts_user ON user_question_attempts(user_id);
CREATE INDEX idx_user_question_attempts_question ON user_question_attempts(question_id);
CREATE INDEX idx_user_question_attempts_user_question ON user_question_attempts(user_id, question_id);
CREATE INDEX idx_user_question_attempts_session ON user_question_attempts(practice_session_id);
CREATE INDEX idx_user_question_attempts_created ON user_question_attempts(created_at);
```

- **answer_option_id**: For multiple choice, the chosen option (the option’s `id`; the order it was shown is in `user_question_attempt_option_order`).
- **answer_value**: For free text questions.
- **is_correct**: Whether the attempt was correct.
- **time_taken_seconds**: Optional time on the question.
- **practice_session_id**: Links to a test run for “My sessions” and session score.
- **RLS**: Users can SELECT, INSERT, UPDATE, DELETE only their own rows (`auth.uid() = user_id`).

#### 12. `user_question_attempt_option_order`

Records the **order in which answer options were shown** to the user for each multiple-choice attempt. Options are displayed in random order per attempt; this table stores that order so the app can reproduce it (e.g. in review) and so analytics know which position the user chose. One row per option per attempt: `display_position` 1 = first option shown, 2 = second, etc.

```sql
CREATE TABLE user_question_attempt_option_order (
    user_question_attempt_id INT NOT NULL REFERENCES user_question_attempts(id) ON DELETE CASCADE,
    display_position INT NOT NULL,
    answer_option_id INT NOT NULL REFERENCES answer_options(id) ON DELETE CASCADE,
    PRIMARY KEY (user_question_attempt_id, display_position),
    UNIQUE (user_question_attempt_id, answer_option_id)
);

CREATE INDEX idx_attempt_option_order_attempt ON user_question_attempt_option_order(user_question_attempt_id);
CREATE INDEX idx_attempt_option_order_option ON user_question_attempt_option_order(answer_option_id);
```

- Populate when the user is shown a multiple-choice question: insert one row per option with the `display_position` used for that attempt.
- **RLS**: Users may access only rows whose attempt belongs to them (e.g. policy: `EXISTS (SELECT 1 FROM user_question_attempts uqa WHERE uqa.id = user_question_attempt_option_order.user_question_attempt_id AND uqa.user_id = auth.uid())` for SELECT, INSERT, UPDATE, DELETE).

#### View: `user_progress_by_topic`

Summary of attempts and correct count per user per topic (and subject).

```sql
CREATE OR REPLACE VIEW user_progress_by_topic AS
SELECT
    uqa.user_id,
    t.id AS topic_id,
    t.name AS topic_name,
    t.subject_id,
    s.code AS subject_code,
    s.name AS subject_name,
    COUNT(*) AS attempts,
    COUNT(*) FILTER (WHERE uqa.is_correct) AS correct,
    ROUND(100.0 * COUNT(*) FILTER (WHERE uqa.is_correct) / NULLIF(COUNT(*), 0), 1) AS pct_correct
FROM user_question_attempts uqa
JOIN questions q ON q.id = uqa.question_id
JOIN topics t ON t.id = q.topic_id
JOIN subjects s ON s.id = t.subject_id
GROUP BY uqa.user_id, t.id, t.name, t.subject_id, s.code, s.name;
```

---

## Triggers and Functions

| Name | Table / Event | Purpose |
|------|----------------|--------|
| `update_updated_at()` | Various tables on UPDATE | Sets `NEW.updated_at = now()` |
| `subjects_updated_at` | subjects | Before UPDATE |
| `topics_updated_at` | topics | Before UPDATE |
| `questions_updated_at` | questions | Before UPDATE |
| `question_sets_updated_at` | question_sets | Before UPDATE |
| `question_statistics_updated_at` | question_statistics | Before UPDATE |
| `profiles_updated_at` | profiles | Before UPDATE |
| `practice_sessions_updated_at` | practice_sessions | Before UPDATE |
| `handle_new_user()` | auth.users AFTER INSERT | Inserts row into `profiles` |
| `on_auth_user_created` | auth.users | Calls `handle_new_user()` |

---

## Row Level Security (RLS)

Enabled only on user/session tables:

| Table | Policies |
|-------|----------|
| `profiles` | SELECT, UPDATE, INSERT own row (`auth.uid() = id`) |
| `practice_sessions` | SELECT, INSERT, UPDATE, DELETE own rows (`auth.uid() = user_id`) |
| `user_question_attempts` | SELECT, INSERT, UPDATE, DELETE own rows (`auth.uid() = user_id`) |
| `user_question_attempt_option_order` | SELECT, INSERT, UPDATE, DELETE rows where the linked attempt belongs to the user (`user_question_attempts.user_id = auth.uid()`) |

Content tables (`subjects`, `topics`, `questions`, etc.) have no RLS in this design; they are read by all authenticated (or anon) users as required by the app.

---

## Design Considerations

### Question Types (`question_type_enum`)

Only two question types are supported:

- **multiple_choice**: Standard 4–5 option questions; user selects one option; correct answer is stored in `correct_answers` with `answer_type = 'option_id'`.
- **free_text**: Open-ended text input; correct answer is stored in `correct_answers` with `answer_type = 'text'` and the expected value in `answer_value`.

### Answer Storage

- **Multiple choice**: Correct answer in `correct_answers` with `answer_type = 'option_id'` and `answer_value` = `answer_options.id` (as text).
- **Free text**: Expected text in `correct_answers.answer_value` with `answer_type = 'text'`.

### Image support

Images for questions and for answer options are supported by storing **URLs** only; the database does not store binary image data.

- **Questions**: The `questions` table has an optional column `question_image_url VARCHAR(500)`. When non-NULL, it holds a single URL (e.g. from Supabase Storage or a CDN) for a diagram or illustration shown with the question. The app is responsible for uploading assets and storing the resulting URL; typical formats (e.g. PNG, JPEG, WebP) are a client concern.
- **Answer options**: The `answer_options` table has an optional column `option_image_url VARCHAR(500)`. When non-NULL, that option can display an image (e.g. a shape, graph, or picture) in addition to or instead of `option_text`. Again, the URL is stored after upload; one URL per option.

Both columns are optional, and the 500-character limit allows long signed URLs if needed. RLS and access to the underlying storage (e.g. Supabase Storage buckets) should be configured separately from this schema.

### Script Order

Run **`create_11plus_supabase.sql`** once in the Supabase SQL Editor. It creates types, core and supporting tables, triggers, user/session tables, RLS policies, the auth trigger, and the progress view in the correct order.

---

## Future Enhancements

- [ ] Support for multi-part questions
- [ ] Question versioning/history
- [ ] Difficulty or performance calibration from statistics (e.g. per topic)
- [ ] Support for audio questions
- [ ] Regional variations (different 11+ formats)
- [ ] RLS or policies on content tables if some content becomes user- or tenant-specific

---

## Notes

- **Database**: PostgreSQL (Supabase). All timestamps use `TIMESTAMPTZ`; identities use `GENERATED BY DEFAULT AS IDENTITY` or UUID from `auth.users`.
- **Auth**: Supabase Auth (`auth.users`). App profile and progress data live in `public.profiles`, `practice_sessions`, and `user_question_attempts`.
- **Implementation**: The executable schema is in `create_11plus_supabase.sql`; this document is the Supabase-specific design reference.
